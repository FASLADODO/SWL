#include "swl/Config.h"
#include "swl/rnd_util/HmmWithVonMisesMixtureObservations.h"
#include "swl/math/MathConstant.h"
#include "RndUtilLocalApi.h"
#include "swl/rnd_util/RejectionSampling.h"
#include <boost/numeric/ublas/matrix_proxy.hpp>
#include <boost/math/constants/constants.hpp>
#include <stdexcept>


#if defined(_DEBUG) && defined(__SWL_CONFIG__USE_DEBUG_NEW)
#include "swl/ResourceLeakageCheck.h"
#define new DEBUG_NEW
#endif


namespace swl {
	
// [ref] swl/src/rnd_util/RndUtilLocalApi.cpp
bool one_dim_root_finding_using_f(const double A, const double lower, const double upper, const std::size_t maxIteration, double &kappa);
double evaluateVonMisesDistribution(const double x, const double mu, const double kappa);

HmmWithVonMisesMixtureObservations::HmmWithVonMisesMixtureObservations(const size_t K, const size_t C)
: base_type(K, 1), HmmWithMixtureObservations(C, K), mus_(K, C, 0.0), kappas_(K, C, 0.0),  // 0-based index
  ms_conj_(), Rs_conj_(), cs_conj_()
{
}

HmmWithVonMisesMixtureObservations::HmmWithVonMisesMixtureObservations(const size_t K, const size_t C, const dvector_type &pi, const dmatrix_type &A, const dmatrix_type &alphas, const dmatrix_type &mus, const dmatrix_type &kappas)
: base_type(K, 1, pi, A), HmmWithMixtureObservations(C, K, alphas), mus_(mus), kappas_(kappas),
  ms_conj_(), Rs_conj_(), cs_conj_()
{
}

HmmWithVonMisesMixtureObservations::HmmWithVonMisesMixtureObservations(const size_t K, const size_t C, const dvector_type *pi_conj, const dmatrix_type *A_conj, const dmatrix_type *alphas_conj, const dmatrix_type *ms_conj, const dmatrix_type *Rs_conj, const dmatrix_type *cs_conj)
: base_type(K, 1, pi_conj, A_conj), HmmWithMixtureObservations(C, K, alphas_conj), mus_(K, C, 0.0), kappas_(K, C, 0.0),
  ms_conj_(ms_conj), Rs_conj_(Rs_conj), cs_conj_(cs_conj)
{
}

HmmWithVonMisesMixtureObservations::~HmmWithVonMisesMixtureObservations()
{
}

void HmmWithVonMisesMixtureObservations::doEstimateObservationDensityParametersByML(const size_t N, const unsigned int state, const dmatrix_type &observations, dmatrix_type &gamma, const double denominatorA)
{
	// reestimate observation(emission) distribution in each state.

	size_t c, n;
	double numerator, denominator;

	// E-step: evaluate zeta.
	// TODO [check] >> frequent memory reallocation may make trouble.
	dmatrix_type zeta(N, C_, 0.0);
	{
		const double eps = 1e-50;
		double val;
		for (n = 0; n < N; ++n)
		{
			const boost::numeric::ublas::matrix_row<const dmatrix_type> obs(observations, n);

			denominator = 0.0;
			for (c = 0; c < C_; ++c)
			{
				//val = alphas_(state, c) * doEvaluateEmissionProbability(state, obs);  // error !!!
				//val = alphas_(state, c) * 0.5 * std::exp(kappas_(state, c) * std::cos(obs[0] - mus_(state, c))) / (MathConstant::PI * boost::math::cyl_bessel_i(0.0, kappas_(state, c)));
				val = alphas_(state, c) * evaluateVonMisesDistribution(obs[0], mus_(state, c), kappas_(state, c));

				zeta(n, c) = val;
				denominator += val;  // this value can be nearly zero if the observation is not generated by the corresponding mixture model.
			}

			if (denominator < eps)
			{
				// FIXME [check] >>
				//	because responsibilities, gamma(y_nc) means membership, the values may become zero if the corresponding mixture model doesn't generate a sample.
				for (c = 0; c < C_; ++c)
					zeta(n, c) = 0.0;
			}
			else
			{
#if 0
				val = 0.999 * gamma(n, state) / denominator;
				for (c = 0; c < C_; ++c)
					zeta(n, c) = 0.001 + val * zeta(n, c);
#else
				val = gamma(n, state) / denominator;
				for (c = 0; c < C_; ++c)
					zeta(n, c) *= val;
#endif
			}
		}
	}

	// M-step.
	const double denominatorAlpha = denominatorA + gamma(N-1, state);
	double sumZeta;
	for (c = 0; c < C_; ++c)
	{
		sumZeta = 0.0;
		for (n = 0; n < N; ++n)
			sumZeta += zeta(n, c);

		// reestimate mixture coefficients(weights).
		alphas_(state, c) = 0.001 + 0.999 * sumZeta / denominatorAlpha;

		// reestimate observation(emission) distribution in each state.
		numerator = denominator = 0.0;
		for (n = 0; n < N; ++n)
		{
			numerator += zeta(n, c) * std::sin(observations(n, 0));
			denominator += zeta(n, c) * std::cos(observations(n, 0));
		}

		double &mu = mus_(state, c);

		// TODO [check] >> check the range of each mu, [0, 2 * pi).
#if 0
		//mu = 0.001 + 0.999 * std::atan2(numerator, denominator);
		mu = 0.001 + 0.999 * std::atan2(numerator, denominator) + MathConstant::PI;
#else
		//mu = std::atan2(numerator, denominator);
		mu = std::atan2(numerator, denominator) + MathConstant::PI;
#endif
		assert(0.0 <= mu && mu < MathConstant::_2_PI);

		//
		numerator = 0.0;
		for (n = 0; n < N; ++n)
			numerator += zeta(n, c) * std::cos(observations(n, 0) - mu);

#if 0
		const double A = 0.001 + 0.999 * numerator / sumZeta;  // -1 < A < 1 (?).
#else
		const double A = numerator / sumZeta;  // -1 < A < 1 (?).
#endif
		// FIXME [modify] >> lower & upper bounds have to be adjusted.
		const double lb = -2000.0, ub = 2000.0;
		const std::size_t maxIteration = 100;
		const bool retval = one_dim_root_finding_using_f(A, lb, ub, maxIteration, kappas_(state, c));
		assert(retval);

		// TODO [check] >>
		if (kappas_(state, c) < 0.0)  // kappa >= 0.0.
		{
			kappas_(state, c) = -kappas_(state, c);
			mu = std::fmod(mu + MathConstant::PI, MathConstant::_2_PI);
			assert(0.0 <= mu && mu < MathConstant::_2_PI);
		}
	}

	// POSTCONDITIONS [] >>
	//	-. all mean directions have to be in [0, 2 * pi).
	//	-. all concentration parameters have to be greater than or equal to 0.
}

void HmmWithVonMisesMixtureObservations::doEstimateObservationDensityParametersByML(const std::vector<size_t> &Ns, const unsigned int state, const std::vector<dmatrix_type> &observationSequences, const std::vector<dmatrix_type> &gammas, const size_t R, const double denominatorA)
{
	// reestimate observation(emission) distribution in each state.

	size_t c, n, r;
	double numerator, denominator;

	// E-step: evaluate zeta.
	// TODO [check] >> frequent memory reallocation may make trouble.
	std::vector<dmatrix_type> zetas;
	zetas.reserve(R);
	for (r = 0; r < R; ++r)
		zetas.push_back(dmatrix_type(Ns[r], C_, 0.0));

	{
		const double eps = 1e-50;
		double val;
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &gammar = gammas[r];
			dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
			{
				const boost::numeric::ublas::matrix_row<const dmatrix_type> obs(observationSequences[r], n);

				denominator = 0.0;
				for (c = 0; c < C_; ++c)
				{
					//val = alphas_(state, c) * doEvaluateEmissionProbability(state, obs);  // error !!!
					//val = alphas_(state, c) * 0.5 * std::exp(kappas_(state, c) * std::cos(obs[0] - mus_(state, c))) / (MathConstant::PI * boost::math::cyl_bessel_i(0.0, kappas_(state, c)));
					val = alphas_(state, c) * evaluateVonMisesDistribution(obs[0], mus_(state, c), kappas_(state, c));

					zetar(n, c) = val;
					denominator += val;  // this value can be nearly zero if the observation is not generated by the corresponding mixture model.
				}

				if (denominator < eps)
				{
					// FIXME [check] >>
					for (c = 0; c < C_; ++c)
						zetar(n, c) = 0.0;
				}
				else
				{
#if 0
					val = 0.999 * gammar(n, state) / denominator;
					for (c = 0; c < C_; ++c)
						zetar(n, c) = 0.001 + val * zetar(n, c);
#else
					val = gammar(n, state) / denominator;
					for (c = 0; c < C_; ++c)
						zetar(n, c) *= val;
#endif
				}
			}
		}
	}

	// M-step.
	double denominatorAlpha = denominatorA;
	for (r = 0; r < R; ++r)
		denominatorAlpha += gammas[r](Ns[r]-1, state);
	const double factor = 0.999 / denominatorAlpha;

	double sumZeta;
	for (c = 0; c < C_; ++c)
	{
		sumZeta = 0.0;
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
				sumZeta += zetar(n, c);
		}

		// reestimate mixture coefficients(weights).
		alphas_(state, c) = 0.001 + factor * sumZeta;

		// reestimate observation(emission) distribution in each state.
		numerator = denominator = 0.0;
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &observationr = observationSequences[r];
			const dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
			{
				numerator += zetar(n, c) * std::sin(observationr(n, 0));
				denominator += zetar(n, c) * std::cos(observationr(n, 0));
			}
		}

		double &mu = mus_(state, c);

		// TODO [check] >> check the range of each mu, [0, 2 * pi).
#if 0
		//mu = 0.001 + 0.999 * std::atan2(numerator, denominator);
		mu = 0.001 + 0.999 * std::atan2(numerator, denominator) + MathConstant::PI;
#else
		//mu = std::atan2(numerator, denominator);
		mu = std::atan2(numerator, denominator) + MathConstant::PI;
#endif
		assert(0.0 <= mu && mu < MathConstant::_2_PI);

		//
		numerator = 0.0;
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &observationr = observationSequences[r];
			const dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
				numerator += zetar(n, c) * std::cos(observationr(n, 0) - mu);
		}

#if 0
		const double A = 0.001 + 0.999 * numerator / sumZeta;  // -1 < A < 1 (?).
#else
		const double A = numerator / sumZeta;  // -1 < A < 1 (?).
#endif
		// FIXME [modify] >> lower & upper bounds have to be adjusted.
		const double lb = -10000.0, ub = 10000.0;
		const std::size_t maxIteration = 100;
		const bool retval = one_dim_root_finding_using_f(A, lb, ub, maxIteration, kappas_(state, c));
		assert(retval);

		// TODO [check] >>
		if (kappas_(state, c) < 0.0)  // kappa >= 0.0.
		{
			kappas_(state, c) = -kappas_(state, c);
			mu = std::fmod(mu + MathConstant::PI, MathConstant::_2_PI);
			assert(0.0 <= mu && mu < MathConstant::_2_PI);
		}
	}

	// POSTCONDITIONS [] >>
	//	-. all mean directions have to be in [0, 2 * pi).
	//	-. all concentration parameters have to be greater than or equal to 0.
}

void HmmWithVonMisesMixtureObservations::doEstimateObservationDensityParametersByMAP(const size_t N, const unsigned int state, const dmatrix_type &observations, dmatrix_type &gamma, const double denominatorA)
{
	// reestimate observation(emission) distribution in each state.

	size_t c, n;
	double numerator, denominator;

	// E-step: evaluate zeta.
	// TODO [check] >> frequent memory reallocation may make trouble.
	dmatrix_type zeta(N, C_, 0.0);
	{
		const double eps = 1e-50;
		double val;
		for (n = 0; n < N; ++n)
		{
			const boost::numeric::ublas::matrix_row<const dmatrix_type> obs(observations, n);

			denominator = 0.0;
			for (c = 0; c < C_; ++c)
			{
				//val = alphas_(state, c) * doEvaluateEmissionProbability(state, obs);  // error !!!
				//val = alphas_(state, c) * 0.5 * std::exp(kappas_(state, c) * std::cos(obs[0] - mus_(state, c))) / (MathConstant::PI * boost::math::cyl_bessel_i(0.0, kappas_(state, c)));
				val = alphas_(state, c) * evaluateVonMisesDistribution(obs[0], mus_(state, c), kappas_(state, c));

				zeta(n, c) = val;
				denominator += val;  // this value can be nearly zero if the observation is not generated by the corresponding mixture model.
			}

			if (denominator < eps)
			{
				// FIXME [check] >>
				//	because responsibilities, gamma(y_nc) means membership, the values may become zero if the corresponding mixture model doesn't generate a sample.
				for (c = 0; c < C_; ++c)
					zeta(n, c) = 0.0;
			}
			else
			{
#if 0
				val = 0.999 * gamma(n, state) / denominator;
				for (c = 0; c < C_; ++c)
					zeta(n, c) = 0.001 + val * zeta(n, c);
#else
				val = gamma(n, state) / denominator;
				for (c = 0; c < C_; ++c)
					zeta(n, c) *= val;
#endif
			}
		}
	}

	// M-step.
	const double denominatorAlpha = denominatorA + gamma(N-1, state);
	double sumZeta;
	for (c = 0; c < C_; ++c)
	{
		sumZeta = 0.0;
		for (n = 0; n < N; ++n)
			sumZeta += zeta(n, c);

		// reestimate mixture coefficients(weights).
		alphas_(state, c) = 0.001 + 0.999 * sumZeta / denominatorAlpha;

		// reestimate observation(emission) distribution in each state.
		numerator = (*Rs_conj_)(state, c) * std::sin((*ms_conj_)(state, c));
		denominator = (*Rs_conj_)(state, c) * std::cos((*ms_conj_)(state, c));
		for (n = 0; n < N; ++n)
		{
			numerator += zeta(n, c) * std::sin(observations(n, 0));
			denominator += zeta(n, c) * std::cos(observations(n, 0));
		}

		double &mu = mus_(state, c);

		// TODO [check] >> check the range of each mu, [0, 2 * pi).
#if 0
		//mu = 0.001 + 0.999 * std::atan2(numerator, denominator);
		mu = 0.001 + 0.999 * std::atan2(numerator, denominator) + MathConstant::PI;
#else
		//mu = std::atan2(numerator, denominator);
		mu = std::atan2(numerator, denominator) + MathConstant::PI;
#endif
		assert(0.0 <= mu && mu < MathConstant::_2_PI);

		//
		numerator = (*Rs_conj_)(state, c) * std::cos(mu - (*ms_conj_)(state, c));
		denominator = sumZeta + (*cs_conj_)(state, c);
		for (n = 0; n < N; ++n)
			numerator += zeta(n, c) * std::cos(observations(n, 0) - mu);

#if 0
		const double A = 0.001 + 0.999 * numerator / denominator;  // -1 < A < 1 (?).
#else
		const double A = numerator / denominator;  // -1 < A < 1 (?).
#endif
		// FIXME [modify] >> lower & upper bounds have to be adjusted.
		const double lb = -2000.0, ub = 2000.0;
		const std::size_t maxIteration = 100;
		const bool retval = one_dim_root_finding_using_f(A, lb, ub, maxIteration, kappas_(state, c));
		assert(retval);

		// TODO [check] >>
		if (kappas_(state, c) < 0.0)  // kappa >= 0.0.
		{
			kappas_(state, c) = -kappas_(state, c);
			mu = std::fmod(mu + MathConstant::PI, MathConstant::_2_PI);
			assert(0.0 <= mu && mu < MathConstant::_2_PI);
		}
	}

	// POSTCONDITIONS [] >>
	//	-. all mean directions have to be in [0, 2 * pi).
	//	-. all concentration parameters have to be greater than or equal to 0.
}

void HmmWithVonMisesMixtureObservations::doEstimateObservationDensityParametersByMAP(const std::vector<size_t> &Ns, const unsigned int state, const std::vector<dmatrix_type> &observationSequences, const std::vector<dmatrix_type> &gammas, const size_t R, const double denominatorA)
{
	// reestimate observation(emission) distribution in each state.

	size_t c, n, r;
	double numerator, denominator;

	// E-step: evaluate zeta.
	// TODO [check] >> frequent memory reallocation may make trouble.
	std::vector<dmatrix_type> zetas;
	zetas.reserve(R);
	for (r = 0; r < R; ++r)
		zetas.push_back(dmatrix_type(Ns[r], C_, 0.0));

	{
		const double eps = 1e-50;
		double val;
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &gammar = gammas[r];
			dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
			{
				const boost::numeric::ublas::matrix_row<const dmatrix_type> obs(observationSequences[r], n);

				denominator = 0.0;
				for (c = 0; c < C_; ++c)
				{
					//val = alphas_(state, c) * doEvaluateEmissionProbability(state, obs);  // error !!!
					//val = alphas_(state, c) * 0.5 * std::exp(kappas_(state, c) * std::cos(obs[0] - mus_(state, c))) / (MathConstant::PI * boost::math::cyl_bessel_i(0.0, kappas_(state, c)));
					val = alphas_(state, c) * evaluateVonMisesDistribution(obs[0], mus_(state, c), kappas_(state, c));

					zetar(n, c) = val;
					denominator += val;  // this value can be nearly zero if the observation is not generated by the corresponding mixture model.
				}

				if (denominator < eps)
				{
					// FIXME [check] >>
					for (c = 0; c < C_; ++c)
						zetar(n, c) = 0.0;
				}
				else
				{
#if 0
					val = 0.999 * gammar(n, state) / denominator;
					for (c = 0; c < C_; ++c)
						zetar(n, c) = 0.001 + val * zetar(n, c);
#else
					val = gammar(n, state) / denominator;
					for (c = 0; c < C_; ++c)
						zetar(n, c) *= val;
#endif
				}
			}
		}
	}

	// M-step.
	double denominatorAlpha = denominatorA;
	for (r = 0; r < R; ++r)
		denominatorAlpha += gammas[r](Ns[r]-1, state);
	const double factor = 0.999 / denominatorAlpha;

	double sumZeta;
	for (c = 0; c < C_; ++c)
	{
		sumZeta = 0.0;
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
				sumZeta += zetar(n, c);
		}

		// reestimate mixture coefficients(weights).
		alphas_(state, c) = 0.001 + factor * sumZeta;

		// reestimate observation(emission) distribution in each state.
		numerator = (*Rs_conj_)(state, c) * std::sin((*ms_conj_)(state, c));
		denominator = (*Rs_conj_)(state, c) * std::cos((*ms_conj_)(state, c));
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &observationr = observationSequences[r];
			const dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
			{
				numerator += zetar(n, c) * std::sin(observationr(n, 0));
				denominator += zetar(n, c) * std::cos(observationr(n, 0));
			}
		}

		double &mu = mus_(state, c);

		// TODO [check] >> check the range of each mu, [0, 2 * pi).
#if 0
		//mu = 0.001 + 0.999 * std::atan2(numerator, denominator);
		mu = 0.001 + 0.999 * std::atan2(numerator, denominator) + MathConstant::PI;
#else
		//mu = std::atan2(numerator, denominator);
		mu = std::atan2(numerator, denominator) + MathConstant::PI;
#endif
		assert(0.0 <= mu && mu < MathConstant::_2_PI);

		//
		numerator = (*Rs_conj_)(state, c) * std::cos(mu - (*ms_conj_)(state, c));
		denominator = sumZeta + (*cs_conj_)(state, c);
		for (r = 0; r < R; ++r)
		{
			const dmatrix_type &observationr = observationSequences[r];
			const dmatrix_type &zetar = zetas[r];

			for (n = 0; n < Ns[r]; ++n)
				numerator += zetar(n, c) * std::cos(observationr(n, 0) - mu);
		}

#if 0
		const double A = 0.001 + 0.999 * numerator / denominator;  // -1 < A < 1 (?).
#else
		const double A = numerator / denominator;  // -1 < A < 1 (?).
#endif
		// FIXME [modify] >> lower & upper bounds have to be adjusted.
		const double lb = -10000.0, ub = 10000.0;
		const std::size_t maxIteration = 100;
		const bool retval = one_dim_root_finding_using_f(A, lb, ub, maxIteration, kappas_(state, c));
		assert(retval);

		// TODO [check] >>
		if (kappas_(state, c) < 0.0)  // kappa >= 0.0
		{
			kappas_(state, c) = -kappas_(state, c);
			mu = std::fmod(mu + MathConstant::PI, MathConstant::_2_PI);
			assert(0.0 <= mu && mu < MathConstant::_2_PI);
		}
	}

	// POSTCONDITIONS [] >>
	//	-. all mean directions have to be in [0, 2 * pi).
	//	-. all concentration parameters have to be greater than or equal to 0.
}

double HmmWithVonMisesMixtureObservations::doEvaluateEmissionProbability(const unsigned int state, const boost::numeric::ublas::matrix_row<const dmatrix_type> &observation) const
{
	double prob = 0.0;
	for (size_t c = 0; c < C_; ++c)
	{
		// each observation are expressed as a random angle, 0 <= observation[0] < 2 * pi. [rad].
		//prob += alphas_(state, c) * 0.5 * std::exp(kappas_(state, c) * std::cos(observation[0] - mus_(state, c))) / (MathConstant::PI * boost::math::cyl_bessel_i(0.0, kappas_(state, c)));
		prob += alphas_(state, c) * evaluateVonMisesDistribution(observation[0], mus_(state, c), kappas_(state, c));
	}

	return prob;
}

void HmmWithVonMisesMixtureObservations::doGenerateObservationsSymbol(const unsigned int state, boost::numeric::ublas::matrix_row<dmatrix_type> &observation, const unsigned int seed /*= (unsigned int)-1*/) const
{
	// PRECONDITIONS [] >>
	//	-. std::srand() had to be called before this function is called.

	const double prob = (double)std::rand() / RAND_MAX;

	double accum = 0.0;
	unsigned int component = (unsigned int)C_;
	for (size_t c = 0; c < C_; ++c)
	{
		accum += alphas_(state, c);
		if (prob < accum)
		{
			component = (unsigned int)c;
			break;
		}
	}

	// TODO [check] >>
	if ((unsigned int)C_ == component)
		component = (unsigned int)(C_ - 1);

	// FIXME [modify] >> these parameters are incorrect.
	if (!targetDist_) targetDist_.reset(new VonMisesTargetDistribution());
	targetDist_->setParameters(mus_(state, component), kappas_(state, component));

#if 0
	if (!proposalDist_) proposalDist_.reset(new UnivariateNormalProposalDistribution());

	{
		// FIXME [modify] >> these parameters are incorrect.
		const double sigma = 1.55;
		const double k = 1.472;
		proposalDist_->setParameters(mus_(state, component), sigma, k);
	}
#else
	if (!proposalDist_) proposalDist_.reset(new UnivariateUniformProposalDistribution());

	{
		const double lower = 0.0;
		const double upper = MathConstant::_2_PI;
		const UnivariateUniformProposalDistribution::vector_type mean_dir(1, mus_(state, component));
		const double k = targetDist_->evaluate(mean_dir) * (upper - lower) * 1.05;
		proposalDist_->setParameters(lower, upper, k);
	}
#endif

	if ((unsigned int)-1 != seed)
		proposalDist_->setSeed(seed);

	swl::RejectionSampling sampler(*targetDist_, *proposalDist_);

	swl::RejectionSampling::vector_type x(D_, 0.0);
	const std::size_t maxIteration = 1000;

	// the range of each observation, [0, 2 * pi)
	const bool retval = sampler.sample(x, maxIteration);
	assert(retval);
	observation[0] = x[0];
}

bool HmmWithVonMisesMixtureObservations::doReadObservationDensity(std::istream &stream)
{
	if (1 != D_) return false;

	std::string dummy;
	stream >> dummy;
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "von") != 0)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "von") != 0)
#endif
		return false;

	stream >> dummy;
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "Mises") != 0)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "Mises") != 0)
#endif
		return false;

	stream >> dummy;
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "mixture:") != 0)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "mixture:") != 0)
#endif
		return false;

	// TODO [check] >>
	size_t C;
	stream >> dummy >> C;  // the number of mixture components
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "C=") != 0 || C_ != C)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "C=") != 0 || C_ != C)
#endif
		return false;

	stream >> dummy;
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "alpha:") != 0)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "alpha:") != 0)
#endif
		return false;

	size_t k, c;

	// K x C
	for (k = 0; k < K_; ++k)
		for (c = 0; c < C_; ++c)
			stream >> alphas_(k, c);

	stream >> dummy;
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "mu:") != 0)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "mu:") != 0)
#endif
		return false;

	// K x C
	for (k = 0; k < K_; ++k)
		for (c = 0; c < C_; ++c)
			stream >> mus_(k, c);

	stream >> dummy;
#if defined(__GNUC__)
	if (strcasecmp(dummy.c_str(), "kappa:") != 0)
#elif defined(_MSC_VER)
	if (_stricmp(dummy.c_str(), "kappa:") != 0)
#endif
		return false;

	// K x C
	for (k = 0; k < K_; ++k)
		for (c = 0; c < C_; ++c)
			stream >> kappas_(k, c);

	return true;
}

bool HmmWithVonMisesMixtureObservations::doWriteObservationDensity(std::ostream &stream) const
{
	stream << "von Mises mixture:" << std::endl;

	stream << "C= " << C_ << std::endl;  // the number of mixture components

	size_t k, c;

	// K x C
	stream << "alpha:" << std::endl;
	for (k = 0; k < K_; ++k)
	{
		for (c = 0; c < C_; ++c)
			stream << alphas_(k, c) << ' ';
		stream << std::endl;
	}

	// K x C
	stream << "mu:" << std::endl;
	for (k = 0; k < K_; ++k)
	{
		for (c = 0; c < C_; ++c)
			stream << mus_(k, c) << ' ';
		stream << std::endl;
	}

	// K x C
	stream << "kappa:" << std::endl;
	for (k = 0; k < K_; ++k)
	{
		for (c = 0; c < C_; ++c)
			stream << kappas_(k, c) << ' ';
		stream << std::endl;
	}

	return true;
}

void HmmWithVonMisesMixtureObservations::doInitializeObservationDensity(const std::vector<double> &lowerBoundsOfObservationDensity, const std::vector<double> &upperBoundsOfObservationDensity)
{
	// PRECONDITIONS [] >>
	//	-. std::srand() had to be called before this function is called.

	// initialize mixture coefficients(weights)
	{
		double sum;
		size_t c;
		for (size_t k = 0; k < K_; ++k)
		{
			sum = 0.0;
			for (c = 0; c < C_; ++c)
			{
				alphas_(k, c) = (double)std::rand() / RAND_MAX;
				sum += alphas_(k, c);
			}
			for (c = 0; c < C_; ++c)
				alphas_(k, c) /= sum;
		}
	}

	// initialize the parameters of observation density
	const std::size_t numLowerBound = lowerBoundsOfObservationDensity.size();
	const std::size_t numUpperBound = upperBoundsOfObservationDensity.size();

	const std::size_t numParameters = K_ * C_ * D_ * 2;  // the total number of parameters of observation density

	assert(numLowerBound == numUpperBound);
	assert(1 == numLowerBound || numParameters == numLowerBound);

	if (1 == numLowerBound)
	{
		const double lb = lowerBoundsOfObservationDensity[0], ub = upperBoundsOfObservationDensity[0];
		size_t c;
		for (size_t k = 0; k < K_; ++k)
			for (c = 0; c < C_; ++c)
			{
				mus_(k, c) = ((double)std::rand() / RAND_MAX) * (ub - lb) + lb;
				kappas_(k, c) = ((double)std::rand() / RAND_MAX) * (ub - lb) + lb;
			}
	}
	else if (numParameters == numLowerBound)
	{
		size_t k, c, idx = 0;
		for (k = 0; k < K_; ++k)
			for (c = 0; c < C_; ++c, ++idx)
				mus_(k, c) = ((double)std::rand() / RAND_MAX) * (upperBoundsOfObservationDensity[idx] - lowerBoundsOfObservationDensity[idx]) + lowerBoundsOfObservationDensity[idx];
		for (k = 0; k < K_; ++k)
			for (c = 0; c < C_; ++c, ++idx)
				kappas_(k, c) = ((double)std::rand() / RAND_MAX) * (upperBoundsOfObservationDensity[idx] - lowerBoundsOfObservationDensity[idx]) + lowerBoundsOfObservationDensity[idx];
	}

#if defined(DEBUG) || defined(_DEBUG)
	for (size_t k = 0; k < K_; ++k)
		for (size_t c = 0; c < C_; ++c)
		{
			assert(0.0 <= mus_(k, c) && mus_(k, c) < MathConstant::_2_PI);
			assert(kappas_(k, c) >= 0.0);
		}
#endif

	// POSTCONDITIONS [] >>
	//	-. all concentration parameters have to be greater than or equal to 0.
}

}  // namespace swl
